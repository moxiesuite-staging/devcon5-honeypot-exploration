const BadGuyContract = artifacts.require("./BadGuyContract.sol");
const PrivateBank = artifacts.require("./PrivateBank.sol");

contract("BadGuyContract", (accounts) => {
  const oneEther = web3.utils.toWei("1");

  let exploit;
  let targetAddress;
  let target;

  before("get deployed instance", async () => {
    exploit = await BadGuyContract.deployed();
  });

  before("get bank instance", async () => {
    // we get this from the exploit contract because we don't deploy it in
    // forked mode. Alternatively we could hand-edit the contract artifact for
    // forked mode, but that's pretty lame.
    targetAddress = await exploit._targetAddress.call();
    target = await PrivateBank.at(targetAddress);
  });

  before("fund bank instance", async () => {
    await web3.eth.sendTransaction({
      from: accounts[0],
      to: targetAddress,
      value: oneEther
    });
  });

  before("fund exploit instance", async () => {
    const initialBadGuyBalance = await exploit.getBalance();
    if (initialBadGuyBalance.toString(10) === "0") {
      await web3.eth.sendTransaction({
        from: accounts[0],
        to: exploit.address,
        value: oneEther
      });
    }
  });

  it("should exploit the PrivateBank contract", async () => {
    // TODOs:
    //  * get the intial balance of the `target`
    //    * make sure it is the expected value: 1 ether

    //  * get the intial balance of the BadGuyContract
    //    * test that it is the expected value: 1 ether

    //  * Run the BadGuyContract's `beBad` function
    //   * hint: `await exploit.beBad();`

    //  * get the new balance of the `target`
    //    * make sure it is the expected value: 0 ether

    //  * get the new balance of the BadGuyContract
    //    * make sure it is the expected value: 2 ether

    assert.fail("Tests not yet implemented! Replace this test with actual tests!");
  });
});
